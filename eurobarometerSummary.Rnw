\documentclass{article}
 
\usepackage[margin= 1in]{geometry} 
\usepackage{parskip}
\usepackage{lscape}

\begin{document}

\section{Eurobarometer Data}
\subsection{Data Overview}
We examine rank data collected in Eurobarometer 34.1. The Eurobarometer is series of surveys conducted by the European Commission to measure public opinion and sentiment across a variety of topics. The standard Eurobarometer survey has been carried out biannually since 1973, and special modules to study specific topics are commissioned frequently as well. In the fall of 1990, Eurobarometer 34.1 was a special module commissioned to study European perspectives on various public health issues. The survey included various questions across a broad spectrum of topics including alcohol consumption, childcare, employment, tobacco use. In particular, we examine the rank data generated by four specific questions. Three separate questions asked respondents to rank policy priorities for addressing AIDs, alcoholism, and illegal drugs. The data we have includes 11872 individuals across the following 13 countries: France, Belgium, Netherlands, West Germany, Italy, Luxembourg, Denmark, Ireland, UK, Greece, Spain, Portual and East Germany.

<<echo = FALSE, fig.align = 'center', fig.width = 6, fig.height = 6, results = 'hide'>>=
library(xtable)
library(mixedMem, quiet = T)
library(batch, quiet = T)
library(foreign)
@

<<echo = FALSE, warning =FALSE>>=
country.names = c("FR", "BG", "NL", "WG", "IT", "LX", "DN", "IR", "UK", "GE", "SP", "PR", "EG", "Total")
setwd("C:/Users/Sam/Dropbox/1 RA - MMS/derivations/euroBarometer")
dat <- read.dta("ZA1961_v1-0-1.dta")
pre.clean.nat <- table(dat$v6)
data1 <- readRDS("~/mixedMem/euro/completeData.rds")
post.clean.nat <- table(data1$v6)

tab <- matrix(0, ncol = dim(pre.clean.nat) + 1, nrow = 2)
rownames(tab) <- c("Individual Counts", "Relative Proportion")
colnames(tab) <- country.names

tab[1, ] <- c(post.clean.nat, sum(post.clean.nat))
tab[2, ] <- c(post.clean.nat/sum(post.clean.nat), 1)
printTab <- cbind(tab[, order(country.names[-14])], tab[, 14])
xtable(printTab[, 1:7], digits = matrix(rep(c(0,2), each = 8), nrow = 2, byrow = T))
xtable(printTab[, 8:14], digits = matrix(rep(c(0,2), each = 8), nrow = 2, byrow = T))
@

<<results = 'asis', echo = FALSE>>=
print(xtable(tab, digits = matrix(rep(c(0,2), each = dim(tab)[2]+1), nrow = dim(tab)[1], ncol = dim(tab)[2] +1, byrow = T)
             , caption = "Nationalities of Respondents in Eurobarometer 34.1"), size = 'footnotesize')
@

\subsection{Survey Questions}
The specific questions we are interested in are as follows:

There are various actions that could be taken to eliminate the drugs problem. In your opinion, what is the first priority? And the next most urgent? (Ask respondent to rank all 7, with 1 as the most urgent).
\begin{enumerate}
\item Information campaigns about the dangers of drugs
\item Hunting down drug pushers and distributors
\item Legal penalty for drug taking
\item Looking after and treating drug addicts and rehabilitating them
\item Funding research into drug substitutes, and into the treatment of drug addiction
\item Fighting the social causes of drug addiction
\item Reinforcing the control or distribution and usage of addictive medicines
\end{enumerate}

There are various actions that could be taken in order to ease the problem of alcoholism and its consequences. Looking at this card, which is the main priority in your view? and the next? (Rank up to 5)
\begin{enumerate}
\item Information campaigns about the danger of alcoholism
\item Stiffer penalties for offences committed under the influence of alcohol
\item Banning advertising for alcoholic drinks
\item Increasing taxes on alcohol
\item Restricting the sale of alcohol. especially to young people
\item Putting lower legal limits on alcohol content
\item Making social outcasts of alcoholics
\item  Helping alcoholics to submit to "drying out"
\item Funding medical research to develop more effective treatments
\item Setting up more reception centers, drying out treatment centers
\end{enumerate}

There are various actions that could be taken in order to eliminate the problem of AIDS or at least to slow down its development. Looking at this card, which is the main priority in your view? And the next? (Rank all by giving a number from 1 to 5. with 1 as a top priority)
\begin{enumerate}
\item Information campaign about the danger
\item Punishment for behavior which increases the risk
\item Identifying and isolating those with AIDS or those who are HIV positive
\item Treating of those with AIDS and looking after them
\item Funding research to find a vaccine
\end{enumerate}


\section{Model}
To model the data, we use a mixed membership model. Mixed membership models extend the mixture model framework by allowing each individual to belong to multiple sub-populations instead of only a single sub-population. In particular, we use the Plackett-Luce model that assumes that individuals select a permutations from a set of V candidates given non-negative support parameters $\theta_v$ for each candidate. For identifiability, the support parameters must sum to 1. Each individual \textit{i} then selects $N_i \leq V$ candidates sequentially, beginning with their highest preference candidate where the probability of selecting one of the remaining candidates at a given ranking level is proportional to the candidates' support parameter.  For a set of support parameters $\{\theta_v\}_{v = 1:V}$ such that $\sum_{v=1}^V \theta_v = 1$ and $\theta_v \geq 0$ for $v=1,\ldots, V$, the mass function for the Plackett-Luce Model is then defined as
\begin{equation}
P(Y_i) = \prod_{n=1}^{N_i}\frac{\theta_{c(n)}}{1-\sum_{\eta =0}^{n-1}\theta_{c(\eta)}}
\end{equation}
where $Y_i$ is a permutation of length $N_i$ of the possible candidates, c(n) indexes the candidate selected at the $n^{th}$ ranking level, and $\theta_{c(0)} =0$. This process can be thought of as a ``multinomial without replacement". With this view, support parameters can also be interpreted as the probabilities of a candidate being ranked first.

The full hierarchical generative model is described below. This is a multivariate generalization of the univariate model proposed by Gormley and Murph 2009. We assume the following fixed quantities: J observed variables with $V_j$ candidates where $V_j$ is known, K latent sub-populations, $\alpha = \{\alpha_1,\ldots,\alpha_K\}$ where each element is positive, and a set of support parameters $\theta_{j,k}$ for each variable j and sub-population k where $\theta_{j,k}$ is a vector which lies in the $V_j$ simplex. 

For each of the $i \in [T]$ individuals:
\begin{itemize} 
\item[(a)] Draw a vector $\lambda_i \sim$ Dirichlet($\alpha$). The vector $\lambda_i$ lies in the K simplex and indicates the degree to which individual i belongs to each of the K sub-populations.
\item[(b)] For each $j \in [J]$ observed variables, $r \in [R_j]$ repeated measures for variable  j, and $n \in  [N_{i,j,r}]$ ranking level for individual i on variable j and repeated measure r:
  	\begin{itemize}
		\item[(1)] Draw $Z_{i,j,r,n} \sim$ $\text{multinomial}(1,\lambda_i)$. Z is an indicator vector of length K, such that $Z_{i,j,r,n,k_0} = 1$ indicates that the support parameters of the $k_0^{th}$ sub-population govern the candidate selection at level n.
		\item[(2)] Draw a candidate $X_{i,j,r,n} \sim$ $\text{Plackett-Luce}(\theta|Z_{i,j,r,n}, X_{i,j,r, \eta < n})$ for ranking level n. $X_{i,j,r,n}$ is an indicator vector of length $V_j$, such that $X_{i,j,r,n,v_0} = 1$ indicates that candidate $v_0$ was chosen at ranking level n. 
		\end{itemize}
\end{itemize}

In the described model, intra-individual mixing of sub-population preferences occurs at each ranking level, not just between variables or repeated measures. Thus, an individual may select their first rank candidate according to the preferences of one sub-population, but select their second rank candidate (from the remaining candidates) according to the preferences of another sub-population. In addition, each individual may provide an incomplete ranking where $N_{i,j,r} \leq V_j$. 


\section{Model Fitting and Selection}
Direct estimation of mixed membership models is intractable in general, so we use a variational EM approach which optimizes a lower bound to the log-likelihood (often the lower bound is called the ELBO). To select the number of sub-populations, we use a held out ELBO criterion. We first select a training set of 6000 individuals and leave the remaining 5782 individuals in a test set. We fit a mixed membership model to the training set, and use the estimated global parameters, $\alpha$ and $\theta$, to calculate the ELBO for the held out test set. Unfortunately, in these models, we find that the ELBO has many local modes so we use 120 different initializations at each level of K = $3,\ldots 10$ to increase the probability of finding a global maxiumum and not just a local model. The model with the highest held out ELBO is selected and we then use then use the corresponding intialization point to fit a model to the entire 11872 indivudals.

We repeated this procedure three times with randomly selected training/test sets and the result from a single batch is shown below. Two of the batches selected similar 4 component models, while 1 batch selected a 5 component model. Presently, we are still thinking about a more principled model selection procedure. Nonetheless, one of the selected 4 component models and the selected 5 component model are presented here.

<<echo = FALSE, message = FALSE, results = 'hide', warnings = T>>=
library(mixedMem)
library(xtable)
try(library(vioplot, quietly = T), silent = T)
@

<<echo = FALSE, message = FALSE,results = 'hide', fig.width = 4, fig.height = 4, fig.align = 'center'>>=
setwd("C:/Users/Sam/Dropbox/1 RA - MMS/derivations/euroBarometer/q3_2fixed_7")

library(batch)
z <- mergeCsv()

elbo.ho3 <- na.omit(z$elbo.ho[z$K == 3])
elbo.ho4<- na.omit(z$elbo.ho[z$K == 4])
elbo.ho5<- na.omit(z$elbo.ho[z$K == 5])
elbo.ho6<- na.omit(z$elbo.ho[z$K == 6])
elbo.ho7<- na.omit(z$elbo.ho[z$K == 7])
elbo.ho8<- na.omit(z$elbo.ho[z$K == 8])
elbo.ho9<- na.omit(z$elbo.ho[z$K == 9])
elbo.ho10<- na.omit(z$elbo.ho[z$K == 10])

vioplot(elbo.ho3, elbo.ho4, elbo.ho5, elbo.ho6, elbo.ho7, elbo.ho8, elbo.ho9,elbo.ho10, col = "lightblue", names = c(3:10))

mtext("Held Out ELBO")
@


\section{Data Analysis}
In our exploratory analysis, we saw a disproportionately large number of ranked responses which simply corresponded to the ordering in which the priorities were presented in the physical survey. Thus, we include two fixed sub-populations. The first sub-population has uniform support over all priorities, the second sub-population has extremely high support corresponding to the ordering of the priorities in the survey.


<<echo = FALSE, results = 'asis'>>=
drug.resp = c("Information campaigns about the dangers of drugs"
              ,"Hunting down drug pushers and distributors","Legal penalty for drug taking"
              ,"Looking after and treating drug addicts and rehabilitating them"
              ,"Funding research into drug substitutes, and into the treatment of drug addiction"
              ,"Fighting the social causes of drug addiction"
              ,"Reinforcing the control or distribution and usage of addictive medicines")

alc.resp = c("Information campaigns about the danger of alcoholism"
             ," Stiffer penalties for offences committed under the influence of alcohol"
             ," Banning advertising for alcoholic drinks"
             ," Increasing taxes on alcohol"
             ," Restricting the sale of alcohol. especially to young people"
             ," Putting lower legal limits on alcohol content"
             ," Making social outcasts of alcoholics"
             ,"  Helping alcoholics to submit to drying out"
             ," Funding medical research to develop more effective treatments"
             ," Setting up more reception centers, drying out treatment centers")

aid.resp = c("Information campaign about the danger"
             ,"Punishment for behavior which increases the risk"
             ,"Identifying and isolating those with AIDS or those who are HIV positive"
             ,"Treating of those with AIDS and looking after them"
             ,"Funding research to find a vaccine")

resp = list(drug.resp, alc.resp, aid.resp)
@


\subsection{Model 1: 4 Component Model}
The optimal selected model here has 4 sub-populations including the 2 fixed groups 
<<echo = FALSE>>=
out <- readRDS("C:/Users/Sam/Dropbox/1 RA - MMS/derivations/euroBarometer/q3_2fixed_7/opt_out7.rds")
@
First we examine the estimated relative frequency of each of the identified sub-populations. The uniform group is group 2 and the rank ordering group is group 3. The other two fitted groups are discussed below. The uniform group (which is meant to simply model noisy responses) is the largest identified group.

We can also see when we plot the grade of membership for each individual's mode sub-population that while some individuals have fairly dispersed sub-population memberships, a large majority of the individuals have very high membership in a single sub-population.

<<>>=
rel.freq <- round(out$alpha/sum(out$alpha),3)
names(rel.freq) <- paste("Group", c(1:4))
rel.freq
@

<<fig.width = 3, fig.height = 3, fig.align = 'center', echo = FALSE>>=
plot(sort(apply(out$phi/rowSums(out$phi),MAR = 1, max)),
     main = "Grade of Membership in Mode", ylab = "Grade of Membership",
          xlab = "Individual", cex = .5, cex.main = .8, pch = 19)
@

When examining the fitted support parameters, we see that group 1 highly favors information campaigns and social programs while group 2 is in favor of more punitive fixes. First we print tables with the estimated support parameters. We also show the results graphically by plotting the support parameters of each group.  The red line shows the weighted average of the support parameters for the 2 non-fixed groups where the weights are the relative frequency of each group. This essentially shows the typical response for those not in the 2 fixed groups.

\begin{landscape}
<<results = 'asis', echo = FALSE>>=
J <- out$J
for(j in 1:J) {
  tab <- matrix(0, ncol = out$K+1, nrow = out$Vj[j])
  tab[, 1] <- resp[[j]][1:out$Vj[j]]
  tab[, -1] <- t(round(out$theta[j,,1:out$Vj[j]],2))
  colnames(tab) <- c("Priorities", paste("Group", c(1:out$K)))
  print(xtable(tab, caption = paste("Question", j),
        table.placement = "h"), size = "\\scriptsize")
}
@
\end{landscape}

<<echo = FALSE>>=
vizT <- function(model, compare = NULL, main = "Estimated Theta",
                    varNames = NULL, groupNames = NULL,nrow = NULL, fitNames = NULL, indices = NULL, qAvg = NULL, ...) {
  
  # Internal Variables to set
  h.space <- .25
  v.space <- .1
  
  if(is.null(varNames)) {
    varNames <- paste("Var", c(1:model$J))
  }
  
  if(is.null(groupNames)) {
    groupNames <- paste("Group", c(1:model$K))
  }
  
  if (is.null(nrow)) {
    nrow <- model$J
  }
  
  if(is.null(indices)) {
    indices <- c(1:model$J)
  }
  
  if(is.null(fitNames)) {
    if(is.null(compare)) { 
      fitNames <- paste("Model", 1)
    } else {
      fitNames <- paste("Model", c(1:2))
    }
  }
  
  par(oma = c(3,5,3,1), mfrow = c(nrow, model$K), mar = rep(.1,4))
  count = 1
  for(j in indices)
  {
    if(model$dist[j]=="multinomial"|model$dist[j]=="rank")
    {
      for(k in 1:model$K)
      {
        plot(model$theta[j,k,], type = "p", lwd = 2, col = "black", ylim = c(-v.space, 1+v.space), xlim = c(h.space, model$Vj[j] + h.space),
             yaxt = "n", xaxt = "n", pch = 16, ...)
        if(!is.null(compare)) {
          lines(c(1:model$Vj[j]), compare[j,k,c(1:model$Vj[j])], col = "red", pch = 4, lwd = 1.5)
        }
        if (k == 1) {
          mtext(varNames[j], line = 3, side = 2, cex = .7)
          axis(side = 2, at = c(0,.5,1), labels = c(0,.5,1))
        }
        if(count == indices[length(indices)]| (count %% nrow) == 0) {
          mtext(paste(groupNames[k], sep = " "), line = .2, side = 1, cex = 1-min(model$J,10)*.4)
        }
      }
    } else if (model$dist[j] == "bernoulli") {
      for(k in 1:model$K) {
        plot(model$theta[j,k,], type = "p", lwd = 2, col = "black", ylim = c(-v.space,1+ v.space), xlim = c(h.space, 1 + h.space),
             yaxt = "n", xaxt = "n", pch = 16, ...)
        if(!is.null(compare)) {
          points(c(1:model$Vj[j]), compare[j,k,], col = "red", pch = 4, lwd = 1.5)
        }
        if(k == 1){
          mtext(varNames[j], line = 3, side = 2, cex = .7)
          axis(side = 2, at = c(0,.5,1), labels = c(0,.5,1))
        }
        if(count == indices[length(indices)]| (count %% nrow) == 0) {
          mtext(paste(groupNames[k], sep = " "), line = .2, side = 1, cex = .8)
        }
      }
    } 
    if((count %% nrow) == 0) {
      title(main = main, outer = T, cex = 1.2)      
      par(fig = c(0, 1, 0, 1), oma = c(0,5,0,1), mar = rep(0, 4), new = T)
      
      plot(0, 0, type = "n", bty = "n", xaxt ="n", yaxt = "n")
      
      if(is.null(compare)){
        legend("bottom", legend = fitNames, pch = 19,
               col = "black", cex = .8)
        
      } else {
        legend("bottom", legend = fitNames,
               pch = c(19, 4), col = c("black", "red"), ncol = 2, cex = .8)
      }
      par(oma = c(3,5,3,1), mfrow = c(nrow, model$K), mar = rep(.1,4))
    }
    count = count + 1
  }
  title(main = main, outer = T, cex = 1.2)      
  par(fig = c(0, 1, 0, 1), oma = c(0,5,0,1), mar = rep(0, 4), new = T)
  
  plot(0, 0, type = "n", bty = "n", xaxt ="n", yaxt = "n")
  
  if(is.null(compare)){
    legend("bottom", legend = fitNames, pch = 19,
           col = "black", cex = .8)
    
  } else {
    legend("bottom", legend = fitNames,
           pch = c(19, 4), col = c("black", "red"), ncol = 2, cex = .8)
  }
  par(oma = c(3,5,3,1), mfrow = c(nrow, model$K), mar = rep(.1,4))
}
@


<<echo = FALSE, fig.align = 'center', fig.width = 4.5, fig.height = 4.5>>=
Vj <- out$Vj
K <- out$K
relFreq <- out$alpha[1:(K-2)]/sum(out$alpha[1:(K-2)])
popAvg <- array(0, dim = c(J, K, max(Vj)))
for(j in 1:J) {
  popAvg[j, , 1:Vj[j]] <- matrix(colSums(out$theta[j,1:(K-2),1:Vj[j]] *relFreq), byrow = T, ncol = Vj[j], nrow = K)
}
vizT(out, compare = popAvg, fitNames = c("Fit Model", "Averages"))
@

We can also view the results on a national level where we take the average individual membership for each and project each nation in a simplex. We see structure that seems somewhat linked to national political ideologies. When we view only the 2 non-fixed groups, we see an even clearer pattern. The UK and Ireland seem the most punitive, while more socialist countries like Denmark, Greece, and Portugal are on the other end of the spectrum.

<<echo = FALSE, fig.align = 'center', fig.width = 4, fig.height = 4>>=
surveyData <- readRDS("C:/Users/Sam/Dropbox/1 RA - MMS/derivations/euroBarometer/euroDataFull.rds")
mem <- out$phi/rowSums(out$phi)
countryMem <- aggregate(mem, by = list(surveyData$v6), mean)

conditional <- cbind(countryMem[,1],countryMem[,c(2,3)]/rowSums(countryMem[,c(2,3,4,5)]), rowSums(countryMem[,4:5])/rowSums(countryMem[,c(2,3,4,5)]))
  
par(mar = c(1,1,1,1))
plot(5,5, ylim = c(-.5, 1), xlim = c(-1,1), xaxt = 'n', yaxt = 'n', 
     ylab = "", xlab = "")
polygon(c(-sqrt(3)/2, 0, sqrt(3)/2, -sqrt(3)/2), c(-.5, 1, -.5, -.5))
countryNames = c("FRA", "BEL", "NED", "WGR", "ITA", "LUX", "DEN", "IRE", "UK", "GRC", "SPA", "POR", "EGR")

axes <- c(pi/2, pi/2 + 2*pi/3, pi/2 + 4*pi/3)
y <- rowSums(t(sin(axes)*t(conditional[,2:4])))
x <- rowSums(t(cos(axes)*t(conditional[,2:4])))
text(x,y,labels = countryNames, cex = .5)
eye <- diag(1, 3)
text(rowSums(cos(axes)*eye),rowSums(sin(axes)*eye), labels = paste("Group", c(1,2,"3/4")))

par(mar = c(2,2,2,2))
conditional <- cbind(countryMem[,1],countryMem[,c(2,3)]/rowSums(countryMem[,c(2,3)]))
plot(conditional[, 2], c(1:length(countryNames)), pch = "", yaxt = "n")
text(conditional[, 2],c(1:length(countryNames)), labels = countryNames)
mtext("Information Group", side = 4)
mtext("Punitive Group", side = 2)
abline(h = c(1:12)+.5, lty = 2)

@


\subsection{Model 2: 5 Component Model}
The optimal selected model here has 5 sub-populations including the 2 fixed groups 
<<echo = FALSE>>=
out <- readRDS("C:/Users/Sam/Dropbox/1 RA - MMS/derivations/euroBarometer/optFixed2_q3HOfull.rds")
@
First we examine the estimated relative frequency of each of the identified sub-populations. The uniform group is group 4 and the rank ordering group is group 5. The other three fitted groups are discussed below. Here we see that the uniform group has a much smaller relative frequency when compared to the previous 4 component model.

We can also see when we plot the grade of membership for each individual's mode sub-population that while some individuals have fairly dispersed sub-population memberships, a large majority of the individuals have very high membership in a single sub-population. This agrees with the previously presented result. 

<<>>=
rel.freq <- round(out$alpha/sum(out$alpha),3)
names(rel.freq) <- paste("Group", c(1:5))
rel.freq
@

<<fig.width = 3, fig.height = 3, fig.align = 'center', echo = FALSE>>=
plot(sort(apply(out$phi/rowSums(out$phi),MAR = 1, max)),
     main = "Grade of Membership in Mode", ylab = "Grade of Membership",
          xlab = "Individual", cex = .5, cex.main = .8, pch = 19)
@

When examining the fitted support parameters, we see that group 1 highly favors information campaigns, group 2 is in favor of more punitive fixes and group 3 seems to support research and rehabilitation. First we print tables with the estimated support parameters. We also show the results graphically by plotting the support parameters of each group.  The red line shows the weighted average of the support parameters for the 2 non-fixed groups where the weights are the relative frequency of each group. This essentially shows the typical response for those not in the 2 fixed groups.

\begin{landscape}
<<results = 'asis', echo = FALSE>>=
J <- out$J
for(j in 1:J) {
  tab <- matrix(0, ncol = out$K+1, nrow = out$Vj[j])
  tab[, 1] <- resp[[j]][1:out$Vj[j]]
  tab[, -1] <- t(round(out$theta[j,,1:out$Vj[j]],2))
  colnames(tab) <- c("Priorities", paste("Group", c(1:out$K)))
  print(xtable(tab, caption = paste("Question", j),
        table.placement = "h"), size = "\\scriptsize")
}
@
\end{landscape}

<<echo = FALSE>>=
vizT <- function(model, compare = NULL, main = "Estimated Theta",
                    varNames = NULL, groupNames = NULL,nrow = NULL, fitNames = NULL, indices = NULL, qAvg = NULL, ...) {
  
  # Internal Variables to set
  h.space <- .25
  v.space <- .1
  
  if(is.null(varNames)) {
    varNames <- paste("Var", c(1:model$J))
  }
  
  if(is.null(groupNames)) {
    groupNames <- paste("Group", c(1:model$K))
  }
  
  if (is.null(nrow)) {
    nrow <- model$J
  }
  
  if(is.null(indices)) {
    indices <- c(1:model$J)
  }
  
  if(is.null(fitNames)) {
    if(is.null(compare)) { 
      fitNames <- paste("Model", 1)
    } else {
      fitNames <- paste("Model", c(1:2))
    }
  }
  
  par(oma = c(3,5,3,1), mfrow = c(nrow, model$K), mar = rep(.1,4))
  count = 1
  for(j in indices)
  {
    if(model$dist[j]=="multinomial"|model$dist[j]=="rank")
    {
      for(k in 1:model$K)
      {
        plot(model$theta[j,k,], type = "p", lwd = 2, col = "black", ylim = c(-v.space, 1+v.space), xlim = c(h.space, model$Vj[j] + h.space),
             yaxt = "n", xaxt = "n", pch = 16, ...)
        if(!is.null(compare)) {
          lines(c(1:model$Vj[j]), compare[j,k,c(1:model$Vj[j])], col = "red", pch = 4, lwd = 1.5)
        }
        if (k == 1) {
          mtext(varNames[j], line = 3, side = 2, cex = .7)
          axis(side = 2, at = c(0,.5,1), labels = c(0,.5,1))
        }
        if(count == indices[length(indices)]| (count %% nrow) == 0) {
          mtext(paste(groupNames[k], sep = " "), line = .2, side = 1, cex = 1-min(model$J,10)*.4)
        }
      }
    } else if (model$dist[j] == "bernoulli") {
      for(k in 1:model$K) {
        plot(model$theta[j,k,], type = "p", lwd = 2, col = "black", ylim = c(-v.space,1+ v.space), xlim = c(h.space, 1 + h.space),
             yaxt = "n", xaxt = "n", pch = 16, ...)
        if(!is.null(compare)) {
          points(c(1:model$Vj[j]), compare[j,k,], col = "red", pch = 4, lwd = 1.5)
        }
        if(k == 1){
          mtext(varNames[j], line = 3, side = 2, cex = .7)
          axis(side = 2, at = c(0,.5,1), labels = c(0,.5,1))
        }
        if(count == indices[length(indices)]| (count %% nrow) == 0) {
          mtext(paste(groupNames[k], sep = " "), line = .2, side = 1, cex = .8)
        }
      }
    } 
    if((count %% nrow) == 0) {
      title(main = main, outer = T, cex = 1.2)      
      par(fig = c(0, 1, 0, 1), oma = c(0,5,0,1), mar = rep(0, 4), new = T)
      
      plot(0, 0, type = "n", bty = "n", xaxt ="n", yaxt = "n")
      
      if(is.null(compare)){
        legend("bottom", legend = fitNames, pch = 19,
               col = "black", cex = .8)
        
      } else {
        legend("bottom", legend = fitNames,
               pch = c(19, 4), col = c("black", "red"), ncol = 2, cex = .8)
      }
      par(oma = c(3,5,3,1), mfrow = c(nrow, model$K), mar = rep(.1,4))
    }
    count = count + 1
  }
  title(main = main, outer = T, cex = 1.2)      
  par(fig = c(0, 1, 0, 1), oma = c(0,5,0,1), mar = rep(0, 4), new = T)
  
  plot(0, 0, type = "n", bty = "n", xaxt ="n", yaxt = "n")
  
  if(is.null(compare)){
    legend("bottom", legend = fitNames, pch = 19,
           col = "black", cex = .8)
    
  } else {
    legend("bottom", legend = fitNames,
           pch = c(19, 4), col = c("black", "red"), ncol = 2, cex = .8)
  }
  par(oma = c(3,5,3,1), mfrow = c(nrow, model$K), mar = rep(.1,4))
}
@


<<echo = FALSE, fig.align = 'center', fig.width = 4.5, fig.height = 4.5>>=
Vj <- out$Vj
K <- out$K
relFreq <- out$alpha[1:(K-2)]/sum(out$alpha[1:(K-2)])
popAvg <- array(0, dim = c(J, K, max(Vj)))
for(j in 1:J) {
  popAvg[j, , 1:Vj[j]] <- matrix(colSums(out$theta[j,1:(K-2),1:Vj[j]] *relFreq), byrow = T, ncol = Vj[j], nrow = K)
}
vizT(out, compare = popAvg, fitNames = c("Fit Model", "Averages"))
@

We can also view the results on a national level where we take the average national membership and plot each nation in a simplex. Note that since group 3 has relatively low relative frequency, the countries are differ primarily on the Group 1 vs Group 2 scale, so we plot the memberships in group 1 vs group 2 as well. Again, we see structure that seems very similar to the previous results.


<<echo = FALSE, fig.align = 'center', fig.width = 3.5, fig.height = 3.5>>=
surveyData <- readRDS("C:/Users/Sam/Dropbox/1 RA - MMS/derivations/euroBarometer/euroDataFull.rds")
mem <- out$phi/rowSums(out$phi)
countryMem <- aggregate(mem, by = list(surveyData$v6), mean)

conditional <- cbind(countryMem[,1],countryMem[,c(2,3,4)]/rowSums(countryMem[,c(2,3,4)]))
  
par(mar = c(1,1,1,1))
plot(5,5, ylim = c(-.5, 1), xlim = c(-1,1), xaxt = 'n', yaxt = 'n', 
     ylab = "", xlab = "")
polygon(c(-sqrt(3)/2, 0, sqrt(3)/2, -sqrt(3)/2), c(-.5, 1, -.5, -.5))
countryNames = c("FRA", "BEL", "NED", "WGR", "ITA", "LUX", "DEN", "IRE", "UK", "GRC", "SPA", "POR", "EGR")

axes <- c(pi/2, pi/2 + 2*pi/3, pi/2 + 4*pi/3)
y <- rowSums(t(sin(axes)*t(conditional[,2:4])))
x <- rowSums(t(cos(axes)*t(conditional[,2:4])))
text(x,y,labels = countryNames, cex = .5)
eye <- diag(1, 3)
text(rowSums(cos(axes)*eye),rowSums(sin(axes)*eye), labels = paste("Group", c(1,2,3)))

par(mar = c(2,2,2,2))
conditional <- cbind(countryMem[,1],countryMem[,c(2,3)]/rowSums(countryMem[,c(2,3)]))
plot(conditional[,2], c(1:length(countryNames)), pch = "", yaxt = "n", xlim = c(.25, .85))
text(conditional[,2],c(1:length(countryNames)), labels = countryNames)
mtext("Information Group", side = 4)
mtext("Punitive Group", side = 2)
abline(h = c(1:12)+.5, lty = 2)

@
\end{document}